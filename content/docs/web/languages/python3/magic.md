# Python Day3 魔法方法

所谓魔术方法，在形式上非常容易辨认：它们总是被双下划线包围，比如我们最熟悉的 `__init__`。在英语中，它们常被称为 "Dunder Methods" (Double Underscore Methods)。它们之所以被称为“魔术”，是因为它们总是在特定的时刻被 Python 解释器自动调用，而不需要我们显式地去触发。掌握了它们，就仿佛掌握了让代码“化繁为简”的魔法，能让我们自定义的对象表现得像 Python 的内置类型一样自然、优雅。

我们可以使用 `dir()` 函数来查看一个对象里隐藏了哪些魔术方法：

```python
class User(object):
    pass

if __name__ == '__main__':
    # dir() 可以列出对象的所有属性和方法
    print(dir(User()))
```

输出结果中那些以 `__` 开头和结尾的就是魔术方法。

## 一、对象的诞生：构造与初始化

我们通常认为创建一个类的实例只需要调用类名即可，但在这个简单的动作背后，其实发生了一个两步走的“诞生仪式”。

首先登场的是 `__new__` 方法。它是真正的“构造者”，负责在内存中开辟空间，创建并返回这个类的实例对象。它就像是负责制造“肉体”的上帝。

紧接着，`__init__` 方法才会介入。它接收 `__new__` 创建出来的实例，并利用传入的参数对这个实例进行属性的设置。它更像是“化妆师”或“教育者”，负责给这个新生的对象赋予初始的状态。

来看一个证明它们调用顺序的例子：

```python
class User(object):
    def __new__(cls, *args, **kwargs):
        print('1. 调用了 __new__ 方法，正在创建对象...')
        # 必须返回父类的 __new__ 才能创建实例
        return super(User, cls).__new__(cls)

    def __init__(self, name, age):
        print('2. 调用了 __init__ 方法，正在初始化对象...')
        self.name = name
        self.age = age

if __name__ == '__main__':
    usr = User('两点水', 23)
```

**运行结果**：
```text
1. 调用了 __new__ 方法，正在创建对象...
2. 调用了 __init__ 方法，正在初始化对象...
```

**个人理解重点**：
大多数时候我们只需要重写 `__init__`，因为默认的“肉体”制造过程已经够用了。但在某些特殊场景下，比如我们需要控制单例模式（确保一个类只有一个实例），或者继承一些不可变类型（如 tuple）时，我们就需要介入 `__new__` 这个更底层的环节。

此外，当对象生命周期结束时，还有一个 `__del__` 方法会被调用，类似于析构函数，负责打扫战场。不过 Python 的垃圾回收机制通常会自动处理得很好，我们很少需要手动去写它。

